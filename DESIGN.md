
This file should describe your design choices and motivates the choices.
I chose to save the process to a variable so that it is accessable and as a global variable for use later in the project
the try and catch phrase was used so that exceptions didn't have to be added to the functions used for ease of use

in the second part I used the spawn function since I can still access the process as it is a global variable to create the process
I then use the inputstream and outputstream in stdin and stdout to take the input and output stream of the process
the 2 streams then get converted to buffered streams and then a scanner to check the output stream and put it into a string and add to that string
and output the output to the console, whilst the scanner is recieving data, after the scanner is finished recieving data, the string that has been added to is output of the function

For part 4, I made the assumption that the process would already be spawned as this would allow for greater usage of the 2 functions as they could work on the same process over and over again. For the "expect" function, I mainly copied over the same code from spawn and collect with timeout and modified it to check if the prompt had been found after each line was accepted from the process, and in doing this, it would work over multiple lines as well. It would be less efficient but more thorough. When I was researching for the spawn and collect code, as well as finding out about the stream reader and buffered reader to go with it, I found out about the stream writer and buffered writer which would allow me to send data into a process, and as such I used the same structure of recieving output from the process and worked it around to work for the input into the process.

For sprint 5 we redesigned the except function to use futures, this allows the input value to be returned as a string from scannnr.hasNext while having a timeout value that will stop the process looking for too long if there is no next line. I found this method meets the requirements but observed that importing a scanner like class that could return nextLine without having to be final would reduce the number of lines of code as all the code on futures could be removed. We separated the spawning of the writer and the scanner into its own functions to prevent it creating it's self more than once, to improve the readability of the code and provide the option to spawn these items in other functions for future development of the process manager. The send function was modified to flush any saved characters from their location in the buffer to their intended destination.